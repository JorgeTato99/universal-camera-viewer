"""
Conexi√≥n gen√©rica para c√°maras chinas sin marca espec√≠fica.
Implementa conexi√≥n RTSP directa para c√°maras que solo exponen puerto 554.
"""

import cv2
import logging
from typing import Optional, Dict, Any, List
from .base_connection import BaseConnection


class GenericConnection(BaseConnection):
    """
    Conexi√≥n gen√©rica para c√°maras chinas sin marca espec√≠fica.
    Especializada en conexiones RTSP directas cuando solo est√° disponible puerto 554.
    Implementa m√∫ltiples patrones de URL RTSP comunes en c√°maras chinas.
    """
    
    def __init__(self, config_manager):
        """
        Inicializa la conexi√≥n gen√©rica.
        
        Args:
            config_manager: Instancia del gestor de configuraci√≥n
        """
        super().__init__(config_manager)
        self.logger = logging.getLogger("GenericConnection")
        
        # Configuraci√≥n espec√≠fica para c√°maras gen√©ricas
        # Priorizar variables de entorno espec√≠ficas de generic si est√°n disponibles
        self.camera_ip = getattr(config_manager, 'generic_ip', None) or getattr(config_manager, 'camera_ip', '192.168.1.100')
        self.username = getattr(config_manager, 'generic_user', None) or getattr(config_manager, 'camera_user', 'admin')
        self.password = getattr(config_manager, 'generic_password', None) or getattr(config_manager, 'camera_password', '')
        self.rtsp_port = getattr(config_manager, 'rtsp_port', 554)
        
        # URLs de stream comunes para c√°maras chinas gen√©ricas
        self.stream_urls = self._generate_stream_urls()
        
        # Estado de conexi√≥n
        self.current_stream_url = None
        self.rtsp_connection = None
        
    def _generate_stream_urls(self) -> List[str]:
        """
        Genera lista de URLs RTSP comunes para probar con c√°maras chinas.
        
        Returns:
            Lista de URLs RTSP ordenadas por probabilidad de √©xito
        """
        urls = []
        base_auth = f"{self.username}:{self.password}@" if self.username and self.password else ""
        base_url = f"rtsp://{base_auth}{self.camera_ip}:{self.rtsp_port}"
        
        # Patrones m√°s comunes en c√°maras chinas gen√©ricas
        patterns = [
            "/stream1",           # Patr√≥n m√°s com√∫n
            "/stream2",           # Stream secundario
            "/live/stream1",      # Variante con /live
            "/live/stream2",      # Stream secundario con /live
            "/stream",            # Patr√≥n simple
            "/live",              # Muy simple
            "/live/main",         # Main stream
            "/live/sub",          # Sub stream
            "/h264",              # Por codec
            "/h264_stream",       # Codec espec√≠fico
            "/video",             # Gen√©rico
            "/cam/realmonitor?channel=1&subtype=0",  # Estilo Dahua
            "/cam/realmonitor?channel=1&subtype=1",  # Dahua sub
            "/user={}&password={}&channel=1&stream=0".format(self.username, self.password),  # Con credenciales en URL
            "/user={}&password={}&channel=1&stream=1".format(self.username, self.password),  # Sub con credenciales
            "/",                  # Root path - √∫ltimo intento
        ]
        
        # Generar URLs completas
        for pattern in patterns:
            urls.append(f"{base_url}{pattern}")
        
        # URLs sin autenticaci√≥n como fallback
        if base_auth:
            no_auth_base = f"rtsp://{self.camera_ip}:{self.rtsp_port}"
            fallback_patterns = ["/stream1", "/live", "/stream", "/"]
            for pattern in fallback_patterns:
                urls.append(f"{no_auth_base}{pattern}")
        
        return urls
    
    def connect(self) -> bool:
        """
        Establece la conexi√≥n RTSP probando m√∫ltiples URLs comunes.
        
        Returns:
            True si la conexi√≥n fue exitosa, False en caso contrario
        """
        try:
            self.logger.info(f"üîå Iniciando conexi√≥n gen√©rica a {self.camera_ip}:{self.rtsp_port}")
            
            # Probar cada URL en orden de probabilidad
            for i, url in enumerate(self.stream_urls, 1):
                try:
                    # Ocultar credenciales en logs
                    safe_url = url.replace(f"{self.username}:{self.password}@", "***:***@") if self.username and self.password else url
                    self.logger.info(f"üéØ Probando URL {i}/{len(self.stream_urls)}: {safe_url}")
                    
                    # Crear capturador OpenCV
                    cap = cv2.VideoCapture(url)
                    
                    # Configurar timeout y buffer
                    cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
                    cap.set(cv2.CAP_PROP_OPEN_TIMEOUT_MSEC, 10000)  # 10 segundos timeout
                    
                    if cap.isOpened():
                        # Intentar leer un frame para confirmar
                        ret, frame = cap.read()
                        
                        if ret and frame is not None:
                            # ¬°Conexi√≥n exitosa!
                            self.rtsp_connection = cap
                            self.current_stream_url = url
                            self.is_connected = True
                            
                            # Obtener informaci√≥n del stream
                            height, width = frame.shape[:2]
                            fps = cap.get(cv2.CAP_PROP_FPS)
                            
                            self.logger.info(f"‚úÖ Conexi√≥n gen√©rica exitosa:")
                            self.logger.info(f"   URL: {safe_url}")
                            self.logger.info(f"   Resoluci√≥n: {width}x{height}")
                            self.logger.info(f"   FPS: {fps}")
                            
                            return True
                        else:
                            # Conexi√≥n abierta pero sin frame
                            cap.release()
                            self.logger.warning(f"‚ö†Ô∏è  URL abierta pero sin frame: {safe_url}")
                    else:
                        # No se pudo abrir
                        cap.release()
                        
                except Exception as e:
                    self.logger.warning(f"‚ùå Error con URL {safe_url}: {str(e)}")
                    continue
            
            self.logger.error("‚ùå No se pudo establecer conexi√≥n con ninguna URL RTSP")
            return False
            
        except Exception as e:
            self.logger.error(f"‚ùå Error general en conexi√≥n gen√©rica: {str(e)}")
            return False
    
    def disconnect(self) -> bool:
        """
        Cierra la conexi√≥n RTSP y libera recursos.
        
        Returns:
            True si se desconect√≥ correctamente
        """
        try:
            if self.rtsp_connection is not None:
                self.rtsp_connection.release()
                self.rtsp_connection = None
            
            self.is_connected = False
            self.current_stream_url = None
            self.logger.info(f"üîå Conexi√≥n gen√©rica cerrada para {self.camera_ip}")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error al desconectar: {str(e)}")
            return False
    
    def is_alive(self) -> bool:
        """
        Verifica si la conexi√≥n est√° activa.
        
        Returns:
            True si la conexi√≥n est√° activa
        """
        if not self.is_connected or self.rtsp_connection is None:
            return False
        
        try:
            return self.rtsp_connection.isOpened()
        except Exception:
            return False
    
    def get_frame(self) -> Optional[Any]:
        """
        Obtiene un frame del stream de video.
        
        Returns:
            Frame de video o None si no est√° disponible
        """
        if not self.is_alive():
            return None
        
        try:
            ret, frame = self.rtsp_connection.read()
            if ret and frame is not None:
                return frame
            else:
                self.logger.warning("‚ö†Ô∏è  No se pudo leer frame del stream gen√©rico")
                return None
                
        except Exception as e:
            self.logger.error(f"‚ùå Error al obtener frame: {str(e)}")
            return None
    
    def get_frame_properties(self) -> Dict[str, Any]:
        """
        Obtiene propiedades del stream de video.
        
        Returns:
            Diccionario con propiedades del stream
        """
        if not self.is_alive():
            return {}
        
        try:
            properties = {
                "width": int(self.rtsp_connection.get(cv2.CAP_PROP_FRAME_WIDTH)),
                "height": int(self.rtsp_connection.get(cv2.CAP_PROP_FRAME_HEIGHT)),
                "fps": self.rtsp_connection.get(cv2.CAP_PROP_FPS),
                "fourcc": int(self.rtsp_connection.get(cv2.CAP_PROP_FOURCC)),
                "buffer_size": int(self.rtsp_connection.get(cv2.CAP_PROP_BUFFERSIZE))
            }
            return properties
            
        except Exception as e:
            self.logger.error(f"‚ùå Error al obtener propiedades: {str(e)}")
            return {}
    
    def save_snapshot(self, filename: str) -> bool:
        """
        Guarda un snapshot del frame actual.
        
        Args:
            filename: Nombre del archivo donde guardar
            
        Returns:
            True si se guard√≥ exitosamente
        """
        frame = self.get_frame()
        if frame is not None:
            try:
                success = cv2.imwrite(filename, frame)
                if success:
                    self.logger.info(f"üì∏ Snapshot guardado: {filename}")
                    return True
                else:
                    self.logger.error(f"‚ùå Error al guardar snapshot: {filename}")
                    return False
            except Exception as e:
                self.logger.error(f"‚ùå Error guardando snapshot: {str(e)}")
                return False
        else:
            self.logger.error("‚ùå No hay frame disponible para snapshot")
            return False
    
    def get_connection_info(self) -> Dict[str, Any]:
        """
        Obtiene informaci√≥n completa de la conexi√≥n.
        
        Returns:
            Diccionario con informaci√≥n de la conexi√≥n
        """
        base_info = super().get_connection_info()
        generic_info = {
            "connection_type": "generic",
            "rtsp_port": self.rtsp_port,
            "current_stream_url": self.current_stream_url.replace(f"{self.username}:{self.password}@", "***:***@") if self.current_stream_url and self.username and self.password else self.current_stream_url,
            "total_urls_tested": len(self.stream_urls),
            "stream_properties": self.get_frame_properties() if self.is_alive() else {}
        }
        
        return {**base_info, **generic_info}
    
    def get_supported_urls(self) -> List[str]:
        """
        Obtiene la lista de URLs soportadas (para debugging).
        
        Returns:
            Lista de URLs que se probaron
        """
        # Versi√≥n segura sin credenciales
        safe_urls = []
        for url in self.stream_urls:
            if self.username and self.password:
                safe_url = url.replace(f"{self.username}:{self.password}@", "***:***@")
            else:
                safe_url = url
            safe_urls.append(safe_url)
        
        return safe_urls 